#!/usr/bin/env python
import subprocess, sys, re, os

from termcolor import colored

class Terminal:
    """
        2013-07-27:
            Wrapper for printing color coded messages to the console

            TODO add backgrounds
    """

    def error(self, msg):
        print(colored("Error: %s" % msg, "red"))

    def failure(self, msg):
        print(colored(msg, "red"))

    def header(self, msg):
        print(colored("--- %s ----" % msg, attrs=["bold","reverse"]))

    def info(self, msg):
        print(colored(msg, "blue"))

    def success(self, msg):
        print(colored(msg, "green"))

    def warn(self, msg):
        print(colored("Warning: %s" % msg, "magenta"))

class Harness(object):

    terminal = Terminal()
    version = "0.3"

    def __init__(self, *args):
        # 2013-07-27: Sanitize arguments?
        self.pattern = args[-1]
        # TODO this is not very error-tolerant
        self.options = dict(zip(args[1:-1:2], args[2:-1:2]))
        self.print_version = ("-v" in self.options) or ("--version" in self.options)

    def compile(self, module_name):
        """
            2013-07-28:
                Compile module + corresponding test case

                TODO handle errors a little cleaner? I worry about the number
                     of if/else branches in the code. Monadize?
                TODO test error handling
        """
        mtuple = (module_name, module_name)
        self.terminal.info("Compiling %s.ml and %s_test.ml" % mtuple)
        try:
            out = subprocess.check_output("ocamlc %s.ml %s_test.ml" % mtuple, shell=True)
            return True
        except subprocess.CalledProcessError as cpe:
            # TODO what's the error? print it much nicer than this
            self.terminal.error("Failed to compile [%s.ml] and [%s_test.ml]" % mtuple)
            return False

    def extract_tester_functions(self, module_name):
        """
            2013-07-28:
                Get a list of callable functions native to `'module_name'.test`
        """
        try:
            functions_string = subprocess.check_output("ocamlc -i %s.cmo %s_test.ml" % (module_name, module_name), shell=True)
            return functions_string.split("\n")
        except subprocess.CalledProcessError as cpe:
            # weird. Should never happen. Can I add a hook to email me / post issue to github?
            self.terminal.info("Compilation passed but could not echo files. This is #unexpected")
            return []

    def find_modules(self, directory):
        """
            2013-07-28:
                Search the filesystem (`directory` on down)
                modules matching the pattern given in the command line args
        """
        # TODO default arg preferable, but not working
        command = " ".join(["find", directory or ".", "-name", "'*%s*_test.ml'" % self.pattern])
        matches = subprocess.check_output(command, shell=True)
        # Matches look like "myfile_test.ml". Filename = the "myfile" part.
        #     also return the path to the file
        for path_to_module in matches.split("\n"):
            # Filter empties
            if path_to_module:
                # Find the last /. This is where the path ends and the module starts
                splitIndex = 0 - (path_to_module[::-1].find("/"))
                path = path_to_module[:splitIndex]
                # Cut off the ".ml" suffix.
                module_name = path_to_module[splitIndex:-8]
                yield (path, module_name)

    def generate_scripts(self, tester_functions, test_name):
        """
            2013-07-23:
                Given a list of defined names (result of compiling the test case),
                prepare unit test scripts to be run in the toplevel environment.

                Ignore and throw warnings for test cases that
                do not have type `unit -> unit`

                TODO make sure utility functions may be included
        """
        test_cases = []
        for defined_name in ( x for x in tester_functions if x ):
            if defined_name.startswith("val "):
                val_name, val_type = defined_name[4:].split(" : ", 1)
                if val_name.startswith("test_"):
                    if val_type != "unit -> unit":
                        self.terminal.warn("skipping test case %s with type %s" % \
                            (val_name, val_type))
                    else:
                        test_cases.append(val_name)
        return ( (test, self.make_toplevel_input(test_name, test))
            for test in test_cases )

    def make_toplevel_input(self, test_name, test):
        """
            2013-07-28:
                Take necessary information & write something to send to the toplevel.
        """
        return "module Test = %s;; Test.%s ();;" % (test_name, test)

    def test_module(self, module_name):
        # TODO accept commandline arguments? (which ones?)
        self.terminal.header("Testing %s.ml" % module_name)
        compilation_succeeded = self.compile(module_name)
        if not compilation_succeeded:
            return False
        self.terminal.info("Compilation succeeded, generating test scripts...")
        self.terminal.info("Generating test scripts for %s" % module_name)
        tester_functions = self.extract_tester_functions(module_name)
        if tester_functions == []:
            self.terminal.warn("Found 0 test cases in %s_test.ml" % module_name)
            return False
        all_pass = True
        test_name = "%s_test" % module_name.capitalize()
        for (fn_name, script) in self.generate_scripts(tester_functions, test_name):
            self.terminal.info("Running %s..." % fn_name)
            test_status = self.run_test(module_name, script)
            all_pass = all_pass and test_status
        return all_pass

    def run(self):
        if self.print_version:
            # TODO sync versioning with github?
            self.terminal.info("ocamltest version %s" % self.version)
            return
        all_pass = True
        cwd = os.getcwd()
        for path, module_name in self.find_modules(self.options.get("-d", None)):
            os.chdir(path)
            module_status = self.test_module(module_name)
            all_pass = all_pass and module_status
            # TODO NEED to execute this line.
            os.chdir(cwd)
        if all_pass:
            self.terminal.success("ALL TESTS PASS")
        else:
            self.terminal.failure("FAILURE")

    def run_test(self, module_name, script):
        """
            2013-07-28:
                Execute a single test script.
        """
        # TODO pass a string to `ocaml` instead?
        with open("/tmp/ocamltest", "w") as f:
            f.write(script)
        try:
            out = subprocess.check_output("ocaml %s.cmo %s_test.cmo /tmp/ocamltest" % (module_name, module_name), shell=True)
            self.terminal.success("success! %s" % out)
            return True
        except subprocess.CalledProcessError as cpe:
            self.terminal.error("fail %s" % cpe)
            return False

if __name__ == "__main__":
    if len(sys.argv) == 1:
        Terminal().info("Usage: ocamltest <pattern>")
    else:
        h = Harness(*sys.argv)
        h.run()
