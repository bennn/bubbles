#!/usr/bin/env python
import subprocess, sys, re, os

from termcolor import colored

class Terminal:
    """
        2013-07-27:
            Wrapper for printing color coded messages to the console

            TODO add backgrounds
    """

    def error(self, msg):
        print(colored("Error: %s" % msg, "red"))

    def failure(self, msg):
        print(colored(msg, "red"))

    def header(self, msg):
        print(colored("--- %s ----" % msg, attrs=["bold","reverse"]))

    def info(self, msg):
        print(colored(msg, "blue"))

    def success(self, msg):
        print(colored(msg, "green"))

    def warn(self, msg):
        print(colored("Warning: %s" % msg, "magenta"))

class Harness(object):

    terminal = Terminal()
    version = "0.3"

    def __init__(self, *args):
        # 2013-07-27: Sanitize arguments?
        self.pattern = args[-1]
        self.options = args[1:-1]
        self.print_version = ("-v" in self.options) or ("--version" in self.options)

    def compile(self, module_name):
        """
            2013-07-28:
                Compile module + corresponding test case

                TODO handle errors a little cleaner? I worry about the number
                     of if/else branches in the code. Monadize?
                TODO test error handling
        """
        mtuple = (module_name, module_name)
        self.terminal.info("Compiling %s.ml and %s_test.ml" % mtuple)
        try:
            out = subprocess.check_output("ocamlc %s.ml %s_test.ml" % mtuple, shell=True)
            return True
        except subprocess.CalledProcessError as cpe:
            # TODO what's the error? print it much nicer than this
            self.terminal.error("Failed to compile [%s.ml] and [%s_test.ml]" % mtuple)
            return False

    def extract_tester_functions(self, module_name):
        """
            2013-07-28:
                Get a list of callable functions native to `'module_name'.test`
        """
        try:
            functions_string = subprocess.check_output("ocamlc -i %s.cmo %s_test.ml" % (module_name, module_name), shell=True)
            return functions_string.split("\n")
        except subprocess.CalledProcessError as cpe:
            # weird. Should never happen. Can I add a hook to email me / post issue to github?
            self.terminal.info("Compilation passed but could not echo files. This is #unexpected")
            return []

    def find_modules(self):
        """
            2013-07-28:
                Search the filesystem (cwd only) for
                modules matching the pattern given in the command line args
        """
        matches = subprocess.check_output("find . -name '*%s*_test.ml'" % self.pattern, shell=True)
        # Matches look like "myfile_test.ml". Just return the "myfile" part.
        # 2013-07-28: Remove the leading ./ too
        return ( test_module[2:-8]
            for test_module in matches.split("\n") if test_module )

    def generate_scripts(self, tester_functions, test_name):
        """
            2013-07-23:
                Given a list of defined names (result of compiling the test case),
                prepare unit test scripts to be run in the toplevel environment.

                Ignore and throw warnings for test cases that
                do not have type `unit -> unit`

                TODO make sure utility functions may be included
        """
        test_cases = []
        for defined_name in ( x for x in tester_functions if x ):
            if defined_name.startswith("val "):
                val_name, val_type = defined_name[4:].split(" : ", 1)
                if val_name.startswith("test_"):
                    if val_type != "unit -> unit":
                        self.terminal.warn("skipping test case %s with type %s" % \
                            (val_name, val_type))
                    else:
                        test_cases.append(val_name)
        return ( (test, self.make_toplevel_input(test_name, test))
            for test in test_cases )

    def make_toplevel_input(self, test_name, test):
        """
            2013-07-28:
                Take necessary information & write something to send to the toplevel.
        """
        return "module Test = %s;; Test.%s ();;" % (test_name, test)

    def test_module(self, module_name):
        # TODO accept commandline arguments? (which ones?)
        self.terminal.header("Testing %s.ml" % module_name)
        compilation_succeeded = self.compile(module_name)
        if not compilation_succeeded:
            return False
        self.terminal.info("Compilation succeeded, generating test scripts...")
        self.terminal.info("Generating test scripts for %s" % module_name)
        tester_functions = self.extract_tester_functions(module_name)
        if tester_functions == []:
            self.terminal.warn("Found 0 test cases in %s_test.ml" % module_name)
            return False
        all_pass = True
        test_name = "%s_test" % module_name.capitalize()
        for (fn_name, script) in self.generate_scripts(tester_functions, test_name):
            self.terminal.info("Running %s..." % fn_name)
            test_status = self.run_test(module_name, script)
            all_pass = all_pass and test_status
        return all_pass

    def run(self):
        if self.print_version:
            # TODO sync versioning with github?
            self.terminal.info("ocamltest version %s" % self.version)
            return
        all_pass = True
        for module_name in self.find_modules():
            module_status = self.test_module(module_name)
            all_pass = all_pass and module_status
        if all_pass:
            self.terminal.success("ALL TESTS PASS")
        else:
            self.terminal.failure("FAILURE")

    def run_test(self, module_name, script):
        """
            2013-07-28:
                Execute a single test script.
        """
        # TODO pass a string to `ocaml` instead?
        with open("/tmp/ocamltest", "w") as f:
            f.write(script)
        try:
            out = subprocess.check_output("ocaml %s.cmo %s_test.cmo /tmp/ocamltest" % (module_name, module_name), shell=True)
            self.terminal.success("success! %s" % out)
            return True
        except subprocess.CalledProcessError as cpe:
            self.terminal.error("fail %s" % cpe)
            return False

if __name__ == "__main__":
    if len(sys.argv) == 1:
        Terminal().info("Usage: ocamltest <pattern>")
    else:
        h = Harness(*sys.argv)
        h.run()
