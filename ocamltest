#!/usr/bin/env python
import subprocess, sys, re, os, time

from termcolor import colored

class Timer:
    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, *args):
        self.end = time.time()
        self.duration = self.end - self.start

class Terminal:
    """
        2013-07-27:
            Wrapper for printing color coded messages to the console

            TODO add backgrounds
    """

    def error(self, msg):
        print(colored("Error: %s" % msg, "red"))

    def failure(self, msg):
        print(colored(msg, "red"))

    def header(self, msg):
        print(colored("--- %s ----" % msg, attrs=["bold","reverse"]))

    def info(self, msg):
        print(colored(msg, "blue"))

    def nocompile(self, msg):
        print(colored("Compilation Failed:\n  %s" % msg.strip().replace("\n", "\n  "), color="red"))
        print("**********************************************************************")
        print("* IF YOU WANT TO SUCCEED IN THIS CLASS YOUR CODE MUST COMPILE -mgn29 *")
        print("**********************************************************************")
        time.sleep(0.7)

    def run(self, msg):
        print(colored(msg, "yellow"))

    def success(self, msg):
        print(colored(msg, "green"))

    def warn(self, msg):
        print(colored("Warning: %s" % msg, "magenta"))

class Harness(object):

    terminal = Terminal()
    version = "0.3"

    def __init__(self, *args):
        # 2013-07-27: Sanitize arguments?
        self.pattern = args[-1]
        # TODO this is not very error-tolerant
        self.options = self.get_options(args[1:-1])
        self.print_version = ("-v" in self.options) or ("--version" in self.options)

    def compile(self, module_name):
        """
            2013-07-28:
                Compile module + corresponding test case

                TODO handle errors a little cleaner? I worry about the number
                     of if/else branches in the code. Monadize?
                TODO test error handling
        """
        ml_file = "%s.ml" % module_name
        test_file = "%s_test.ml" % module_name
        self.terminal.info("Compiling %s and %s" % (ml_file, test_file))
        try:
            command = " ".join(["ocamlc", ml_file, test_file])
            subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
            return True
        except subprocess.CalledProcessError as cpe:
            self.terminal.nocompile(cpe.output)
            return False

    def find_modules(self, directory):
        """
            2013-07-28:
                Search the filesystem (`directory` on down)
                modules matching the pattern given in the command line args
        """
        directory = self._directory_fallback(directory)
        command = " ".join(["find", directory, "-name", "'*%s*_test.ml'" % self.pattern])
        matches = subprocess.check_output(command, shell=True)
        # Matches look like "myfile_test.ml". Filename = the "myfile" part.
        #     also return the path to the file
        for path_to_module in matches.split("\n"):
            # Filter empties
            if path_to_module:
                # Find the last /. This is where the path ends and the module starts
                splitIndex = 0 - (path_to_module[::-1].find("/"))
                path = path_to_module[:splitIndex]
                # Cut off the ".ml" suffix.
                module_name = path_to_module[splitIndex:-8]
                yield (path, module_name)

    def generate_scripts(self, tester_functions, test_name):
        """
            2013-07-23:
                Given a list of defined names (result of compiling the test case),
                prepare unit test scripts to be run in the toplevel environment.

                Ignore and throw warnings for test cases that
                do not have type `unit -> unit`

                TODO make sure utility functions may be included
        """
        # TODO not at all optimized to save comparisons
        test_cases = []
        for defined_name in ( x for x in tester_functions if x ):
            if defined_name.startswith("val "):
                val_name, val_type = defined_name[4:].split(" : ", 1)
                if val_name.startswith("test_"):
                    if val_type != "unit -> unit":
                        self.terminal.warn("skipping test case %s with type %s" % \
                            (val_name, val_type))
                    else:
                        test_cases.append(val_name)
        if test_cases == []:
            return None
        else:
            return ( (test, self.make_toplevel_input(test_name, test))
                for test in test_cases )

    def get_options(self, args):
        args = self._collapse_flags(args)
        return dict(zip(args[:2], args[1:2]))

    def get_values(self, module_name):
        """
            2013-07-28:
                Get a list of values defined in '`module_name`.test'
        """
        try:
            command = " ".join(["ocamlc", "-i", "%s.cmo" % module_name, "%s_test.ml" % module_name])
            functions_string = subprocess.check_output(command, shell=True)
            return functions_string.split("\n")
        except subprocess.CalledProcessError as cpe:
            # weird. Should never happen. Can I add a hook to email me / post issue to github?
            self.terminal.info("Compilation passed but could not echo files. This is #unexpected")
            return []

    def make_toplevel_input(self, test_name, test):
        """
            2013-07-28:
                Take necessary information & write something to send to the toplevel.
        """
        return "%s.%s ();;" % (test_name.capitalize(), test)

    def test_module(self, module_name):
        # TODO accept commandline arguments? (which ones?)
        self.terminal.header("Testing %s.ml" % module_name)
        if not self.compile(module_name):
            return False
        self.terminal.info("Compilation succeeded! Generating test scripts...")
        values = self.get_values(module_name)
        all_pass = True
        test_name = "%s_test" % module_name.capitalize()
        test_scripts = self.generate_scripts(values, test_name)
        if test_scripts is None:
            self.terminal.warn("No test cases in %s_test.ml" % module_name)
            return None
        for (fn_name, script) in test_scripts:
            self.terminal.run("Running %s..." % fn_name)
            test_status = self.run_test(module_name, script)
            all_pass = all_pass and test_status
        return all_pass

    def run(self):
        if self.print_version:
            # TODO sync versioning with github?
            self.terminal.info("ocamltest version %s" % self.version)
            return
        all_pass = True
        cwd = os.getcwd()
        with Timer() as t:
            for path, module_name in self.find_modules(self.options.get("-d", None)):
                os.chdir(path)
                module_status = self.test_module(module_name)
                all_pass = all_pass and module_status
                # TODO NEED to execute this line.
                os.chdir(cwd)
        if all_pass:
            self.terminal.success("ALL TESTS PASS in %0.3f seconds" % t.duration)
        else:
            self.terminal.failure("FAILURE in %0.3f seconds" % t.duration)

    def run_test(self, module_name, script):
        """
            2013-07-28:
                Execute a single test script.
                Start a toplevel with the module and test case object files loaded, 
                pipe in the test script as an argument.

                I'm not entirely happy with the piping because it means that subprocess
                fails to throw an error when the test fails. Maybe fix that later.
        """
        # TODO add assertions and helpers library object files
        command = " ".join([
            "echo \"%s\" |" % script, 
            "ocaml", "%s.cmo" % module_name,  
            "%s_test.cmo" % module_name
        ])
        with Timer() as t:
            try:
                out = subprocess.check_output(command, shell=True)
            except subprocess.CalledProcessError as cpe:
                # TODO what kind of craziness is gonna show up here?
                self.terminal.error("failed to run %s_test: %s" % (module_name, cpe.output))
                return False
        test_passed, message = self._check_output(out, t.duration)
        if test_passed:
            self.terminal.success(message)
        else:
            self.terminal.failure(message)
        return test_passed

    def _check_output(self, toplevel_output, duration):
        """
            2013-08-04:
                Toplevel output is always echoed to subprocess, regardless of
                whether the tests passed. Manually check if the code raised an
                assertion error. 
                
                TODO this is not very rigorous! It assumes there will be exactly two
                octothorps in the output, and that the text we care about lies between
                them!
        """
        message = re.search(r"#(.*)\n#", toplevel_output).group(1).strip()
        if message == "- : unit = ()":
            return True, "PASS in %0.3f seconds\n" % duration
        else:
            return False, "FAIL with '%s' in %0.3f seconds\n" % (message, duration)

    def _collapse_flags(self, args):
        new_args = []
        for arg in args:
            if arg.startswith("--"):
                new_args.append(arg[1:3])
            else:
                new_args.append(arg)
        return new_args

    def _directory_fallback(self, directory):
        """
            2013-07-28:
                Q: which part of the filesystem should we search for test files?
                A: the part the user specified with an option,
                   the part set in an environment variable,
                   or the current working directory
        """
        if directory:
            return directory
        elif os.environ.get('OCAMLTEST_HOME'):
            return os.environ['OCAMLTEST_HOME']
        else:
            return os.getcwd()

    def _print_help(self):
        """
            2013-07-28:
                Documentation stub.
        """
        hs = [
            "Supported options:",
            "-d --directory : use this directory as the base for the suite", #2013-07-28: TODO explain this better
            "-h --help : print this message",
            "-v --version : echo version number, then quit",
        ]
        return "\n".join(hs)

if __name__ == "__main__":
    if len(sys.argv) == 1:
        Terminal().info("Usage: ocamltest <pattern>")
    else:
        h = Harness(*sys.argv)
        h.run()
