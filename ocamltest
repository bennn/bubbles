#!/usr/bin/env python
import subprocess, sys, re, os

from termcolor import colored

class Terminal:
    """
        2013-07-27:
            Wrapper for printing color coded messages to the console

            TODO add backgrounds
    """

    def error(self, msg):
        print(colored("Error: %s" % msg, "red"))

    def failure(self, msg):
        print(colored(msg, "red"))

    def header(self, msg):
        print(colored("--- %s ----" % msg, attrs=["bold","reverse"]))

    def info(self, msg):
        print(colored(msg, "blue"))

    def success(self, msg):
        print(colored(msg, "green"))

    def warn(self, msg):
        print(colored("Warning: %s" % msg, "magenta"))

class Harness(object):

    terminal = Terminal()
    version = "0.3"

    def __init__(self, *args):
        # 2013-07-27: Sanitize arguments?
        self.pattern = args[-1]
        # TODO this is not very error-tolerant
        self.options = self.get_options(args[1:-1])
        self.print_version = ("-v" in self.options) or ("--version" in self.options)

    def compile(self, module_name):
        """
            2013-07-28:
                Compile module + corresponding test case

                TODO handle errors a little cleaner? I worry about the number
                     of if/else branches in the code. Monadize?
                TODO test error handling
        """
        ml_file = "%s.ml" % module_name
        test_file = "%s_test.ml" % module_name
        self.terminal.info("Compiling %s and %s" % (ml_file, test_file))
        try:
            command = " ".join(["ocamlc", ml_file, test_file])
            out = subprocess.check_output(command, shell=True)
            return True
        except subprocess.CalledProcessError as cpe:
            # TODO what's the error? print it much nicer than this
            self.terminal.error("Failed to compile [%s] and [%s_test]" % (ml_file, test_file))
            return False

    def extract_tester_functions(self, module_name):
        """
            2013-07-28:
                Get a list of callable functions native to `'module_name'.test`
        """
        try:
            command = " ".join(["ocamlc", "-i", "%s.cmo" % module_name, "%s_test.ml" % module_name])
            functions_string = subprocess.check_output(command, shell=True)
            return functions_string.split("\n")
        except subprocess.CalledProcessError as cpe:
            # weird. Should never happen. Can I add a hook to email me / post issue to github?
            self.terminal.info("Compilation passed but could not echo files. This is #unexpected")
            return []

    def find_modules(self, directory):
        """
            2013-07-28:
                Search the filesystem (`directory` on down)
                modules matching the pattern given in the command line args
        """
        directory = self._directory_fallback(directory)
        command = " ".join(["find", directory, "-name", "'*%s*_test.ml'" % self.pattern])
        matches = subprocess.check_output(command, shell=True)
        # Matches look like "myfile_test.ml". Filename = the "myfile" part.
        #     also return the path to the file
        for path_to_module in matches.split("\n"):
            # Filter empties
            if path_to_module:
                # Find the last /. This is where the path ends and the module starts
                splitIndex = 0 - (path_to_module[::-1].find("/"))
                path = path_to_module[:splitIndex]
                # Cut off the ".ml" suffix.
                module_name = path_to_module[splitIndex:-8]
                yield (path, module_name)

    def generate_scripts(self, tester_functions, test_name):
        """
            2013-07-23:
                Given a list of defined names (result of compiling the test case),
                prepare unit test scripts to be run in the toplevel environment.

                Ignore and throw warnings for test cases that
                do not have type `unit -> unit`

                TODO make sure utility functions may be included
        """
        # TODO not at all optimized to save comparisons
        test_cases = []
        for defined_name in ( x for x in tester_functions if x ):
            if defined_name.startswith("val "):
                val_name, val_type = defined_name[4:].split(" : ", 1)
                if val_name.startswith("test_"):
                    if val_type != "unit -> unit":
                        self.terminal.warn("skipping test case %s with type %s" % \
                            (val_name, val_type))
                    else:
                        test_cases.append(val_name)
        return ( (test, self.make_toplevel_input(test_name, test))
            for test in test_cases )

    def get_options(self, args):
        args = self._collapse_flags(args)
        return dict(zip(args[:2], args[1:2]))

    def make_toplevel_input(self, test_name, test):
        """
            2013-07-28:
                Take necessary information & write something to send to the toplevel.
        """
        return "%s.%s ();;" % (test_name.capitalize(), test)

    def test_module(self, module_name):
        # TODO accept commandline arguments? (which ones?)
        self.terminal.header("Testing %s.ml" % module_name)
        compilation_succeeded = self.compile(module_name)
        if not compilation_succeeded:
            return False
        self.terminal.info("Compilation succeeded, generating test scripts...")
        self.terminal.info("Generating test scripts for %s" % module_name)
        tester_functions = self.extract_tester_functions(module_name)
        if tester_functions == []:
            self.terminal.warn("Found 0 test cases in %s_test.ml" % module_name)
            return False
        all_pass = True
        test_name = "%s_test" % module_name.capitalize()
        for (fn_name, script) in self.generate_scripts(tester_functions, test_name):
            self.terminal.info("Running %s..." % fn_name)
            test_status = self.run_test(module_name, script)
            all_pass = all_pass and test_status
        return all_pass

    def run(self):
        if self.print_version:
            # TODO sync versioning with github?
            self.terminal.info("ocamltest version %s" % self.version)
            return
        all_pass = True
        cwd = os.getcwd()
        for path, module_name in self.find_modules(self.options.get("-d", None)):
            os.chdir(path)
            module_status = self.test_module(module_name)
            all_pass = all_pass and module_status
            # TODO NEED to execute this line.
            os.chdir(cwd)
        if all_pass:
            self.terminal.success("ALL TESTS PASS")
        else:
            self.terminal.failure("FAILURE")

    def run_test(self, module_name, script):
        """
            2013-07-28:
                Execute a single test script.
                Start a toplevel with the module and test case object files loaded, 
                pipe in the test script as an argument.

                I'm not entirely happy with the piping because it means that subprocess
                fails to throw an error when the test fails. Maybe fix that later.
        """
        # TODO add assertions and helpers library object files
        command = " ".join([
            "echo \"%s\" |" % script, 
            "ocaml", "%s.cmo" % module_name,  
            "%s_test.cmo" % module_name
        ])
        try:
            out = subprocess.check_output(command, shell=True)
        except subprocess.CalledProcessError as cpe:
            self.terminal.error("failed to run %s_test: %s" % (module_name, cpe))
            return False
        test_passed, message = self._check_output(out)
        if test_passed:
            self.terminal.success(message)
        else:
            self.terminal.failure(message)
        return test_passed

    def _check_output(self, toplevel_output):
        """
            2013-08-04:
                Toplevel output is always echoed to subprocess, regardless of
                whether the tests passed. Manually check if the code raised an
                assertion error. 
                
                TODO this is not very rigorous! It assumes there will be exactly two
                octothorps in the output, and that the text we care about lies between
                them!
        """
        message = re.search(r"#(.*)\n#", toplevel_output).group(1)
        if message == " - : unit = ()":
            return True, "PASS"
        else:
            return False, "FAIL with '%s'" % message

    def _collapse_flags(self, args):
        new_args = []
        for arg in args:
            if arg.startswith("--"):
                new_args.append(arg[1:3])
            else:
                new_args.append(arg)
        return new_args

    def _directory_fallback(self, directory):
        """
            2013-07-28:
                Q: which part of the filesystem should we search for test files?
                A: the part the user specified with an option,
                   the part set in an environment variable,
                   or the current working directory
        """
        if directory:
            return directory
        elif os.environ.get('OCAMLTEST_HOME'):
            return os.environ['OCAMLTEST_HOME']
        else:
            return os.getcwd()

    def _print_help(self):
        """
            2013-07-28:
                Documentation stub.
        """
        hs = [
            "Supported options:",
            "-d --directory : use this directory as the base for the suite", #2013-07-28: TODO explain this better
            "-h --help : print this message",
            "-v --version : echo version number, then quit",
        ]
        return "\n".join(hs)

if __name__ == "__main__":
    if len(sys.argv) == 1:
        Terminal().info("Usage: ocamltest <pattern>")
    else:
        h = Harness(*sys.argv)
        h.run()
