#!/usr/bin/env python
import subprocess, sys, re, os

from util.harness import Harness
from util.invalidTestException import InvalidTestException
from util.log import Log
from util.timer import Timer

class Main(object):

    DEFAULT_TIMEOUT = 20
    github_url = "https://github.com/bennn/bubbles"
    SUPPORTED_OPTIONS = {
        "-h" : "--help : Print this message, then exit.",
        "-t" : "--timeout : Set the time limit (in seconds) for tests. Default is %s seconds." % DEFAULT_TIMEOUT,
        "-v" : "--version : Echo version number, then exit.",
    }
    version = "1.00"

    def __init__(self, *args):
        # TODO support test pattern matching, instead of run all 
        self.log = Log()
        self.solution_dir, self.student_dir, self.timeout = self.parse_args(args[1:])

    def find_modules(self):
        """
            2013-07-28:
                First search `self.solution_dir` for test cases
                Ensure that matching implementation files exist (weakly assure)
                Finally search `self.student_dir` for matching implementation files
        """
        find_command = " ".join([
            "find", 
            self.solution_dir, 
            "-name", 
            "'*_test.ml'"
        ])
        matchesStr = ""
        try:
            matchesStr = subprocess.check_output(find_command, shell=True)
        except subprocess.CalledProcessError as cpe:
            self.log.error("Something went horribly wrong finding the solution files")
            exit(1)
        # Got solution tests, make sure matching files exist for each
        output = []
        for m in (x for x in matchesStr.split("\n") if x):
            splitByFolder = m.split("/")
            sol_dir = "/".join(splitByFolder[:-1])
            test_name = splitByFolder[-1]
            if re.search(r"[\s]", test_name):
                self.log.warn("Skipping test case '%s'. There should be no whitespace in filenames." % src_name)
            else:
                src_nosuffix = test_name[:-(len("_test.ml"))]
                sol_name = "%s_sol.ml" % src_nosuffix
                src_name = "%s.ml" % src_nosuffix
                sol = "%s/%s" % (sol_dir, sol_name)
                if not os.path.exists(sol):
                    self.log.warn("Skipping test case '%s'. No matching implementation file found." % src_name)
                else:
                    # Find the student file, if exists
                    find_command = " ".join(["find", self.student_dir, "-name", "'%s'" % src_name])
                    try:
                        matchesStr = subprocess.check_output(find_command, shell=True)
                        matches = matchesStr.split("\n")
                    except subprocess.CalledProcessError as cpe:
                        self.log.error("Something went terribly wrong finding student file '%s'" % impl_name)
                        exit(1)
                    if not matches:
                        self.log.warn("Could not find student file '%s'" % impl_name)
                    else:
                        stu_dir = "/".join(matches[0].split("/")[:-1])
                        output.append((src_name, sol_dir, stu_dir))
        return output

    def parse_args(self, args):
        """
            2013-08-26:
                Return solution dir, student dir, timeout

                TODO support multiple student dirs
        """
        solution_dir = None
        student_dir = None
        timeout = None
        i = 0
        while i < len(args):
            if args[i] == "-t" or args[i] == "--timeout":
                if timeout is not None:
                    self.log.error("Invalid arguments. Timeout set twice in '%s'" % " ".join(self.args))
                    exit(1)
                else:
                    try:
                        timeout = args[i+1]
                        i += 2
                    except IndexError:
                        self.log.error("Missing value for timeout at tail end of args: '%s'" % " ".join(self.args))
            else:
                if solution_dir is None:
                    solution_dir = args[i]
                elif student_dir is None:
                    student_dir = args[i]
                else:
                    self.print_usage()
                    exit(1)
                i += 1
        if (solution_dir is None) or (student_dir is None):
            self.print_usage()
            exit(1)
        else:
            return solution_dir, student_dir, (timeout or self.DEFAULT_TIMEOUT)

    def print_help(self):
        """
            2013-07-28:
                Documentation stub.
        """
        help_message = [
            "  Test the files in <student-dir> against the corresponding files and test cases in <solution-dir>",
            "Supported options:"
        ]
        self.print_usage()
        print("\n".join(help_message))
        self.print_supported_options()

    def print_supported_options(self):
        print("\n".join(( "%s %s" % (k, self.SUPPORTED_OPTIONS[k])
            for k in sorted(self.SUPPORTED_OPTIONS.keys()))))

    def print_usage(self):
        print("Usage: ocamltest [-t <timeout>] <solution-dir> <student-dir>")

    def print_version(self):
        """
            2013-08-25:
                Echo the current version number
        """
        print("ocamltest version %s\nHome directory: %s\nStay updated at: %s" % (self.version, os.getcwd(), self.github_url))

    def run(self):
        """
            2013-08-23:
                Handle control flow, find the test files to be run,
                run a harness for each test file

                TODO briefly check finding

                TODO rename 'harness', to differentiate between those single 
                harnesses and the entire test suite. I guess 'harness.py' can be
                'test.py'... it refers to a single file
        """
        # Make sure everything's installed well enough
        self._check_install()
        # Find test files
        to_run = list(self.find_modules())
        if not bool(to_run):
            # No tests, terminate early
            self.log.warn("Found 0 tests matching pattern")
            return
        self.log.debug("TO_RUN = %s" % to_run)
        # We have tests! Start a timer and run them.
        error_messages = {}
        with Timer() as t:
            for (src_name, sol_dir, stu_dir) in to_run:
                try: 
                    failures = Harness(src_name, sol_dir, stu_dir, self.timeout).run()
                    if bool(failures):
                        # 2013-08-23: Something went wrong, better record it.
                        test_name = test_file.split("/")[-1][:-(len(".ml"))]
                        error_messages[test_name] = failures
                except InvalidTestException as e:
                    # Optionally do something based on status code
                    pass
        self.log.header("Results")
        if bool(error_messages):
            self.log.pprint_failures(error_messages, t.duration)
        else: 
            self.log.success("ALL TESTS PASS in %0.3f seconds" % t.duration)

    def _check_install(self):
        """
            2013-08-22:
                Ensure that everything's installed properly, give descriptive
                warnings if it is not.

                Requirements:
                - OCAMLTEST_HOME env. variable is set. I don't care where it points,
                    but it's supposed to point to the project root, where you want
                    to test from by default
                - ocamltest.ml is installed wherever ocamlc expects to find it
        """
        ocamltest_files = ['ocamltest.cma', 'ocamltest.cmi', 'ocamltest.cmo']
        find_files = ( subprocess.check_output("find `ocamlc -where` -name '%s'" % fname, shell=True)
            for fname in ocamltest_files )
        if not (len(ocamltest_files) == len([x for x in find_files if x])):
            self.log.error("\n".join([
                "ocamltest.ml not properly installed. You may either:",
                "       - Run `make install` with root permissions",
                "       - Manually compile 'ocamltest.ml', creating a .cma library (`ocamlc -a -o ocamltest.ml`) and then",
                "         moving 'ocamltest.cma', 'ocamltest.cmo', and 'ocamltest.cmi' to wherever your ocaml standard library files are stored.",
            ]))
            exit(1)

    def _timeout(self):
        """
            2013-08-25:
                Get the timeout, if supplied and valid. 
                Raise an exception for an invalid timeout, return the default
                timeout otherwise.
        """
        if "-t" not in self.options:
            return self.DEFAULT_TIMEOUT
        else:
            timeoutStr = self.options['-t']
            try: 
                timeout = float(timeoutStr)
                if timeout < 0: 
                    raise ValueError
                else:
                    return timeout
            except ValueError:
                self.log.error("-t expected a postive number, received '%s'" % timeoutStr)
                exit(1)

if __name__ == "__main__":
    # First, check the short-circuit options
    options = set(sys.argv)
    if "-v" in options or "--version" in options:
        Main().print_version()
    elif "-h" in options or "--help" in options:
        Main().print_help()
    else: # Run some tests
        h = Main(*sys.argv)
        h.run()
