#!/usr/bin/env python
import subprocess, sys, re, os

from util.harness import Harness
from util.invalidTestException import InvalidTestException
from util.log import Log
from util.timer import Timer

class Main(object):

    DEFAULT_TIMEOUT = 20
    github_url = "https://github.com/bennn/bubbles"
    log = Log()
    SUPPORTED_OPTIONS = {
        "-h" : "--help : Print this message, then exit.",
        "-t" : "--timeout : Set the time limit (in seconds) for tests. Default is %s seconds." % DEFAULT_TIMEOUT,
        "-v" : "--version : Echo version number, then exit.",
    }
    version = "1.00"

    def find_modules(self, student_dir):
        """
            2013-07-28:
                First search `self.solution_dir` for test cases
                Ensure that matching implementation files exist (weakly assure)
                Finally search `student_dir` for matching implementation files
        """
        find_command = " ".join([
            "find", 
            self.solution_dir, 
            "-name", 
            "'*_test.ml'"
        ])
        matchesStr = ""
        try:
            matchesStr = subprocess.check_output(find_command, shell=True)
        except subprocess.CalledProcessError as cpe:
            self.log.error("Something went horribly wrong finding the solution files")
            exit(1)
        # Got solution tests, make sure matching files exist for each
        output = []
        for m in (x for x in matchesStr.split("\n") if x):
            splitByFolder = m.split("/")
            sol_dir = "/".join(splitByFolder[:-1])
            test_name = splitByFolder[-1]
            if re.search(r"[\s]", test_name):
                self.log.warn("Skipping test case '%s'. There should be no whitespace in filenames." % src_name)
            else:
                src_nosuffix = test_name[:-(len("_test.ml"))]
                sol_name = "%s_sol.ml" % src_nosuffix
                src_name = "%s.ml" % src_nosuffix
                sol = "%s/%s" % (sol_dir, sol_name)
                if not os.path.exists(sol):
                    self.log.warn("Skipping test case '%s'. No matching implementation file found." % src_name)
                else:
                    # Find the student file, if exists
                    find_command = " ".join(["find", student_dir, "-name", "'%s'" % src_name])
                    try:
                        matchesStr = subprocess.check_output(find_command, shell=True)
                        matches = matchesStr.split("\n")
                    except subprocess.CalledProcessError as cpe:
                        self.log.error("Something went terribly wrong finding student file '%s'" % impl_name)
                        exit(1)
                    if not matches:
                        self.log.warn("Could not find student file '%s'" % impl_name)
                    else:
                        stu_dir = "/".join(matches[0].split("/")[:-1])
                        output.append((src_name, sol_dir, stu_dir))
        return output

    def parse_args(self, args):
        """
            2013-08-26:
                Return solution dir, student dir, timeout

                The timeout should be the first argument, if it exists.
                Solution directory follows, then all student directories

        """
        timeout = None
        # Parse timeout
        if args[0] == "-t" or args[0] == "--timeout":
            if len(args) < 4:
                self.print_usage()
                exit(1)
            try: 
                timeout = float(args[1])
                if timeout < 0: raise ValueError
            except ValueError:
                self.log.error("-t expected a postive number, received '%s'" % timeoutStr)
                exit(1)
            solution_dir = args[2]
            student_dirs = args[3:]
        else:
            solution_dir = args[0]
            student_dirs = args[1:]
        return solution_dir, student_dirs, timeout

    def print_help(self):
        """
            2013-07-28:
                Documentation stub.
        """
        help_message = [
            "  Test the files in <student-dir> against the corresponding files and test cases in <solution-dir>",
            "Supported options:"
        ]
        self.print_usage()
        print("\n".join(help_message))
        self.print_supported_options()

    def print_supported_options(self):
        print("\n".join(( "%s %s" % (k, self.SUPPORTED_OPTIONS[k])
            for k in sorted(self.SUPPORTED_OPTIONS.keys()))))

    def print_usage(self):
        print("Usage: ocamltest [-t <timeout>] <solution-dir> <student-dir>")

    def print_version(self):
        """
            2013-08-25:
                Echo the current version number
        """
        print("ocamltest version %s\nHome directory: %s\nStay updated at: %s" % (self.version, os.getcwd(), self.github_url))

    def run(self, args):
        """
            2013-08-23:
                Handle control flow, find the test files to be run,
                run a harness for each test file

                TODO rename 'harness', to differentiate between those single 
                harnesses and the entire test suite. I guess 'harness.py' can be
                'test.py'... it refers to a single file
        """
        # Make sure everything's installed well enough
        self._check_install()
        # TODO setting fields here is not good for clarity
        self.solution_dir, student_dirs, self.timeout = self.parse_args(args)
        for student_dir in self._infer_student_directories(student_dirs):
            with self.log.Student(student_dir):
                self.run_student(student_dir)
            
    def run_student(self, student_dir):
        """
            2013-08-28:
                TODO the 'with' syntax would be awesome here. 
                Enter and exit could control printouts
        """
        # Find test files
        to_run = list(self.find_modules(student_dir))
        if not bool(to_run):
            # No tests, terminate early
            self.log.warn("Found 0 tests matching pattern")
            return
        # We have tests! Start a timer and run them.
        error_messages = {}
        with Timer() as t:
            for (src_name, sol_dir, stu_dir) in to_run:
                try: 
                    failures = Harness(src_name, sol_dir, stu_dir, self.timeout).run()
                    if bool(failures):
                        # 2013-08-23: Something went wrong, better record it.
                        test_name = src_name
                        error_messages[test_name] = failures
                except InvalidTestException as e:
                    # Optionally do something based on status code
                    pass
        # TODO don't use header anymore. Delete it
        self.log.header("Results")
        if bool(error_messages):
            self.log.pprint_failures(error_messages, t.duration)
        else: 
            self.log.success("ALL TESTS PASS in %0.3f seconds" % t.duration)

    def _check_install(self):
        """
            2013-08-22:
                Ensure that everything's installed properly, give descriptive
                warnings if it is not.

                Requirements:
                - OCAMLTEST_HOME env. variable is set. I don't care where it points,
                    but it's supposed to point to the project root, where you want
                    to test from by default
                - ocamltest.ml is installed wherever ocamlc expects to find it
        """
        ocamltest_files = ['ocamltest.cma', 'ocamltest.cmi', 'ocamltest.cmo']
        find_files = ( subprocess.check_output("find `ocamlc -where` -name '%s'" % fname, shell=True)
            for fname in ocamltest_files )
        if not (len(ocamltest_files) == len([x for x in find_files if x])):
            self.log.error("\n".join([
                "ocamltest.ml not properly installed. You may either:",
                "       - Run `make install` with root permissions",
                "       - Manually compile 'ocamltest.ml', creating a .cma library (`ocamlc -a -o ocamltest.ml`) and then",
                "         moving 'ocamltest.cma', 'ocamltest.cmo', and 'ocamltest.cmi' to wherever your ocaml standard library files are stored.",
            ]))
            exit(1)

    def _infer_student_directories(self, student_dirs):
        """
            2013-08-26:
                If the commandline argument for student directories
                begins with an @ symbol, like '@./Submissions/netids`, 
                interpret the argument as the name of a file containing
                the names of folders that ought to be searched. 

                Currently, only  one @argument may be given. The code throws 
                a warning and ignores they extra if additional args are present
                after one beginning with an @. 
        """
        path = student_dirs[0]
        if path.startswith("@"):
            if len(student_dirs) > 1:
                self.log.warn("Inferring directory names from '%s', ignoring proceeding arguments %s" % (path, student_dirs[1:]))
            path = path[1:]
            inferred_student_dirs = []
            if "/" in path:
                # Strip from the last '/' to the end of the filepath
                containing_folder = path[::-1].split("/", 1)[1][::-1]
            else:
                containing_folder = "."
            with open(path, 'r') as f:
                for dirname in f:
                    inferred_student_dirs.append("%s/%s" % (containing_folder, dirname.strip()))
            return inferred_student_dirs
        else:
            return student_dirs

if __name__ == "__main__":
    # First, check the short-circuit options
    options = set(sys.argv)
    if "-v" in options or "--version" in options:
        Main().print_version()
    elif "-h" in options or "--help" in options:
        Main().print_help()
    elif (len(sys.argv) < 2) or (sys.argv[0].startswith("-") and len(sys.argv) < 4): 
        Main().print_usage()
    else: 
        Main().run(sys.argv[1:])
