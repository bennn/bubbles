#!/usr/bin/env python
import subprocess, sys, re, os

from util.cmsGradesTable import CmsGradesTable
from util.harness import Harness
from util.invalidTestException import InvalidTestException
from util.log import Log
from util.noCompileException import NoCompileException
from util.postscript import Postscript
from util.timer import Timer

class Main(object):

    DEFAULT_TIMEOUT = 20
    github_url = "https://github.com/bennn/bubbles"
    log = Log()
    pattern = ""
    timeout = DEFAULT_TIMEOUT
    SUPPORTED_OPTIONS = {
        "-h" : "--help : Print this message, then exit.",
        "-p" : "--pattern : Only run tests matching the supplied pattern. Trailing glob implied.",
        "-t" : "--timeout : Set the time limit (in seconds) for tests. Default is %s seconds." % DEFAULT_TIMEOUT,
        "-v" : "--version : Echo version number, then exit.",
    }
    version = "1.00"

    def find_modules(self, solution_dir, student_dir, pattern):
        """
            2013-07-28:
                First search `solution_dir` for test cases
                Ensure that matching implementation files exist (weakly assure)
                Finally search `student_dir` for matching implementation files
        """
        find_command = " ".join([
            "find", 
            solution_dir, 
            "-name", 
            "'%s*_test.ml'" % pattern,
        ])
        matchesStr = ""
        try:
            matchesStr = subprocess.check_output(find_command, shell=True)
        except subprocess.CalledProcessError as cpe:
            self.log.error("Something went horribly wrong finding the solution files located in %s" % solution_dir)
            exit(1)
        # Got solution tests, make sure matching files exist for each
        output = []
        for m in (x for x in matchesStr.split("\n") if x):
            splitByFolder = m.split("/")
            sol_dir = "/".join(splitByFolder[:-1])
            test_name = splitByFolder[-1]
            if re.search(r"[\s]", test_name):
                self.log.warn("Skipping test case '%s'. There should be no whitespace in filenames." % src_name)
            else:
                module_name = test_name[:-(len("_test.ml"))]
                sol_name = "%s_sol.ml" % module_name
                src_name = "%s.ml" % module_name
                sol = "%s/%s" % (sol_dir, sol_name)
                if not os.path.exists(sol):
                    self.log.warn("Skipping test case '%s'. No matching implementation file found." % src_name)
                else:
                    # Find the student file, if exists
                    find_command = " ".join([
                        "find", 
                        student_dir, 
                        "-name", 
                        "'%s'" % src_name
                    ])
                    try:
                        matchesStr = subprocess.check_output(find_command, shell=True)
                        matches = matchesStr.split("\n")
                    except subprocess.CalledProcessError as cpe:
                        self.log.error("Something went terribly wrong finding student file '%s'" % src_name)
                        exit(1)
                    if not matches:
                        self.log.warn("Could not find student file '%s'" % impl_name)
                    else:
                        stu_dir = "/".join(matches[0].split("/")[:-1])
                        output.append((module_name, sol_dir, stu_dir))
        return output

    def parse_args(self, args):
        """
            2013-08-26:
                Return solution dir, student dir, timeout

                The timeout should be the first argument, if it exists.
                Solution directory follows, then all student directories
        """
        if args[0].startswith("-"):
            if args[0].startswith("--"):
                collapsed = args[0][2]
            else:
                collapsed = args[0][1]
            if collapsed == 'p':
                self.pattern = self._parse_pattern(args[1])
            elif collapsed == 't':
                self.timeout = self._parse_timeout(args[1])
            else:
                self.log.warn("Unsupported option %s" % args[0])
            return self.parse_args(args[2:])
        else: 
            try:
                solution_dir = args[0]
                student_dirs = args[1:]
                return solution_dir, student_dirs
            except IndexError:
                self.print_usage()
                exit(1)

    def print_help(self):
        """
            2013-07-28:
                Documentation stub.
        """
        help_message = [
            "  Test the files in <student-dir> against the corresponding files and test cases in <solution-dir>",
            "Supported options:"
        ]
        self.print_usage()
        print("\n".join(help_message))
        self.print_supported_options()

    def print_supported_options(self):
        print("\n".join(( "%s %s" % (k, self.SUPPORTED_OPTIONS[k])
            for k in sorted(self.SUPPORTED_OPTIONS.keys()))))

    def print_usage(self):
        print("Usage: harness311 [options] <solution-dir> <student-dir>")

    def print_version(self):
        """
            2013-08-25:
                Echo the current version number
        """
        print("ocamltest version %s\nHome directory: %s\nStay updated at: %s" % (self.version, os.getcwd(), self.github_url))

    def run(self, args):
        """
            2013-08-23:
                Handle control flow, find the test files to be run,
                run a harness for each test file

                TODO rename 'harness', to differentiate between those single 
                harnesses and the entire test suite. I guess 'harness.py' can be
                'test.py'... it refers to a single file
        """
        # Make sure everything's installed well enough
        self._check_install()
        solution_dir, student_dirs = self.parse_args(args)
        grades_table = CmsGradesTable()
        for student_dir in self._infer_student_directories(student_dirs):
            net_id = self._net_id(student_dir)
            with self.log.Student(student_dir):
                errors = self.run_student(solution_dir, student_dir, net_id)
                grades_table.update(net_id, errors)
        grades_table.export()
            
    def run_student(self, solution_dir, student_dir, net_id):
        """
            2013-08-28:
        """
        # Find test files
        to_run = list(self.find_modules(solution_dir, student_dir, self.pattern))
        if not bool(to_run):
            # No tests, terminate early
            self.log.warn("Found 0 tests matching pattern")
            return
        # We have tests! Start a timer and run them.
        error_messages = {}
        # TODO this should be a test context. Create a new enscript file, time it, etc
        with Timer() as t:
            for (name, sol_dir, stu_dir) in to_run:
                output_stream = Postscript(net_id, name)
                output_stream.write_code("%s/%s.ml" % (stu_dir, name))
                failed = None
                try: 
                    failures = Harness(name, sol_dir, stu_dir, self.timeout).run()
                    if bool(failures):
                        output_stream.write_failures(failures)
                        error_messages[name] = failures
                    else:
                        output_stream.write_success()
                except NoCompileException as e:
                    output_stream.write_nocompile(e.message)
                    error_messages[name] = [("NO COMPILE", [e.message])]
                except InvalidTestException as e:
                    # Optionally do something based on status code
                    pass
        self.log.header("Summary of Results")
        if bool(error_messages):
            self.log.pprint_failures(error_messages, t.duration)
        else: 
            self.log.success("ALL TESTS PASS in %0.3f seconds" % t.duration)
        return error_messages

    def _check_install(self):
        """
            2013-08-22:
                Ensure that everything's installed properly, give descriptive
                warnings if it is not.

                Requirements:
                - OCAMLTEST_HOME env. variable is set. I don't care where it points,
                    but it's supposed to point to the project root, where you want
                    to test from by default
                - ocamltest.ml is installed wherever ocamlc expects to find it
        """
        ocamltest_files = ['ocamltest.cma', 'ocamltest.cmi', 'ocamltest.cmo']
        find_files = ( subprocess.check_output("find `ocamlc -where` -name '%s'" % fname, shell=True)
            for fname in ocamltest_files )
        if not (len(ocamltest_files) == len([x for x in find_files if x])):
            self.log.error("\n".join([
                "ocamltest.ml not properly installed. You may either:",
                "       - Run `make install` with root permissions",
                "       - Manually compile 'ocamltest.ml', creating a .cma library (`ocamlc -a -o ocamltest.ml`) and then",
                "         moving 'ocamltest.cma', 'ocamltest.cmo', and 'ocamltest.cmi' to wherever your ocaml standard library files are stored.",
            ]))
            exit(1)
            
    def _net_id(self, filepath):
        if "/" in filepath:
            return filepath[::-1].split("/",1)[0][::-1]
        else:
            return filepath

    def _infer_student_directories(self, student_dirs):
        """
            2013-08-26:
                If the commandline argument for student directories
                begins with an @ symbol, like '@./Submissions/netids`, 
                interpret the argument as the name of a file containing
                the names of folders that ought to be searched. 

                Currently, only  one @argument may be given. The code throws 
                a warning and ignores they extra if additional args are present
                after one beginning with an @. 
        """
        path = student_dirs[0]
        if path.startswith("@"):
            if len(student_dirs) > 1:
                self.log.warn("Inferring directory names from '%s', ignoring proceeding arguments %s" % (path, student_dirs[1:]))
            path = path[1:]
            inferred_student_dirs = []
            if "/" in path:
                # Strip from the last '/' to the end of the filepath
                containing_folder = path[::-1].split("/", 1)[1][::-1]
            else:
                containing_folder = "."
            with open(path, 'r') as f:
                for dirname in f:
                    inferred_student_dirs.append("%s/%s" % (containing_folder, dirname.strip()))
            return inferred_student_dirs
        else:
            return student_dirs

    def _parse_pattern(self, pattern):
        """
            2013-08-30:
                This is straightforward. The pattern is just a string. A prefix for a filename.
                Not sure what an invalid one might be.
        """
        if pattern.startswith("/"):
            self.log.error("Invalid pattern '%s'" % pattern)
            exit(1)
        return pattern

    def _parse_timeout(self, timeout_str):
        try: 
            timeout = float(args[1])
            if timeout < 0: raise ValueError
        except ValueError:
            self.log.error("-t expected a postive number, received '%s'" % timeout_str)
            exit(1)
        return timeout

if __name__ == "__main__":
    # First, check the short-circuit options
    options = set(sys.argv)
    if "-v" in options or "--version" in options:
        Main().print_version()
    elif "-h" in options or "--help" in options:
        Main().print_help()
    elif (len(sys.argv) < 2) or (sys.argv[0].startswith("-") and len(sys.argv) < 4): 
        Main().print_usage()
    else: 
        Main().run(sys.argv[1:])
